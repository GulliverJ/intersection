Paths
 - Labelled clockwise from the top, left road only, e.g.

 		0,1,2

    9,10,11			
			3,4,5

	   6,7,8

 - Right turn, then straight, then left turn
	> if path % 3 = 2, then it's straight


JUNCTION REGIONS - clockwise from top-left, centre = 4, top-left = 1...
 - 0, 1, 2, 3, 4

PATH REQUIREMENTS (this is a 2D array, has order)

0	0,4,2
1	0,1
2	0
3	1,4,3
4	1,2
5	1
6	2,4,0
7	2,3
8	2
9	3,4,1
10	3,0
11	3


Car Object
 - Speed
 - Path
 - Acceleration


Active Vechicles List
 - FIFO list

List for each junction region?



//// ALGORITHM - runs every frame

If (new car)
 - Set up variables to temporarily store its ETA at the junction/ETA for each box
 - Check its path
 - Estimate best ETA, ETD for box 1
	> Bear in mind that if it's turning it needs to slow down; best it can do is arrive at the junction
	  at that speed, and maintain it until it reaches the last block and is turning out of it
 - Check box 1
 - Check its nextFree (+ safety)
	> If -1, it's free anyway so just get it
	> Otherwise, check if there's a window encompassing ETA and ETD
	> Set ETA to the best option out of nextFree and the start of the window
 - With that juncETA, 
	> Calculate speed at arrival
		- Should be target speed based on which path it's taking
		- Take into account deceleration
	> Calculate ETA of leaving box 1 (half way point of car) - don't forget safety padding
		- Update box's scheduledNextFree, maintain nextFree
		- set local variable nextBoxArrival
 - If need box 2, 
	> Check its nextFree
		If its nextFree < nextBoxArrival, NAB IT and lock temporarily, then move on
		Otherwise, nextFree > nextBoxArrival (so if we have to wait for it)
			- Check if there's a suitable matching window; if not...
			- reset the target to coincide with this box's nextFree
				> If we used a window for a previous box, check there is no conflict
					- If there is, reset everything to match the latest nextFree in the list

 - If need box 3, same as above

 - So from the previous block, we figured out the quickest time we can reach our destination at hte far end of the
   junction. Next, check if thisPath % 4 == lastBlockCarPath % 4 (store car obj?)
	> If it does
		- Check the exit speed/acceleration of that car
		- Calculate a safer ETD where you maximise your speed whilst staying at least 2 metres away
			Approach 1: Set the ETD to be less than last guy's ETD by the amount of time it'd take you
				    to get right up his arse
				    So the car in front with set an ETA for being up to top speed.
					Based on that we can figure out how far away it'll be
					   Just need to set out ETA such that we'll be 4 metres behind at the same
					   time and at the same speed

 - So, knowing our ETD, for a path that is clear, we can figure out the ETAs for each block, do that
 - Iterate through each block and set their nextFree and other details
 - That car's schedule is now locked in and will not change. Compelte for the other new cars

Update Position
For each car:
 - Update position by (acceleration * time dif + speed) * tidif
 - Update acceleration based on targets and whatever
 - Update rotation according to what it's up to

OPTIMIZATION
 - Just have the cars rotate about an axis, don't worry about mathematics
 - Schedule each car progressively frame by frame rather than all at once
 - Have linear accel/decel only

Okay:

		EStimate time of arrival
		Check first box
		If have to wait, calculate arrival speed
		Box makes best-case calculation (car acceleration a, box width s, u) to get the time to cross
			Also calculate the worst-case time where we maintain speed through the junction (car accel = 0, u, box width s)
		Adds this to curTime to get the ETD for the box
		If there's a second box...
			If next box needs more time than best
				if it needs more time than worst
					Add the time it needs OVER the worst time to the original ETA
					Set acceleration for the car to arrive in this time, at same speed as before, for worst
					Recalculate the nextFree of box 1		
				Based on arrival speed u, and distance through box d, find arrival time for box2
				box2 is last box, so set appropriate accel (max accel?) and calculate the nextFree of box 2
			else
				Use suvat to calculate the nextFree of each, given that you'll be at max speed/accelerating to max speed as you pass through
		else
			set that time as nextFree for the first box		
		+ safetyBuffer to the nextFree of each box we will drive through

I need to re-write all of this algorithm because it is just too dumb
 - Need to consider how we handle changing acceleration and who is really in charge of it.
	will 


			



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Intersection Sizes
 - 1m = 	16px
 - Lane Width: 	62px
 - Centre Lane:	31px
 - Curve Start:	194px
 - leftTurn:	158px

Car: 32px * 75px

LEFT TURN PIVOTS - 155px
RIGHT TURN PIVOTS - 94px

SPEEDS:
210	13m/s		30mph
288	18m/s		40mph

-----

MVP:

 - Implement a radius of foresight, or just spawn all vehicles the same distance away from the junction
	> Second idea is better for now
 - Figure out how to handle acceleration and speed more sensibly
	> Might need to use the idea of stages more appropriately.
	> Stage 0: approaching
		> Has an acceleration associated with it
	> Stage 1: entering the junction
		> Has a max speed associated with it
		> If on a curve, max speed is limited to curve max
		> If straight, max speed is max speed
		> Note: one-box paths will have a stage 1, measuring their progress up to 45 degrees
	> Stage 2: leaving the junction
		> At this point, vehicles have a clear run ahead and can accelerate to max speed
	> When setting ETA, can decide the full speed graph for a car passing through
	> Look at the earliest time you can arrive as the latest ETD
		- Can't start accelerating til stage 2, let's just decide that
		- Delay ETA
		- Update nextFree 
	> Check how soon you'll get to the next box 
 - Re-write scheduling algorithm to include centre block
 - Test a lot and tweak
 - Implement 'window opportunities'
 - Try a 4-lane one
 - Set up figure-of-8 page

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

LATER

 - Shrinking radius visually - fading edges to slide over the graphic
 - Set privilege in one direction?
 - 4 lanes on one, 2 on the other?
 - 8 track
 - Graphics: infinite road?
 - Parabolic/functions for the curves (distance from pivot)

NOTE: Junction will specify its own suggested speeds based on curviness.

NOTE: WHen two cars are on the same kind of path (%3), there'll never be a race condition; order holds



NOTE: For now, ALWAYS YIELD. Once a car is locked in, it's locked in.

NOTE: For each region, maintain a "Window" array. A window is a period of time greater than the safety limit
      (say, at least half a second) between a car leaving the region and the next car entering the region. In this
      time, it may be possible that another car can be scheduled to pass through the region.
	nextFree will be the latest time after whcih there are no 'windows', or no more locked-in cars.

ON DEFAULT, it'll take maybe half a second for a car to drive at max permitted speed across the intersection in a
	    line.

Say the speed = 50kmph, then it'd take 0.86 secs to get across, or 1 with safety padding..?
	> TODO: Set the speed as a slider?

NOTE: Have to make sure a car can accelerate out of the way in time
	> In the block, store the path of the car
		- If carPathID % 4 == lastCarPathID % 4, then need to make sure it'll have time to accelerate
	 	  away. So we also need to store the curSpeed and curVelocity of the car that's going to be
		  leaving (an estimate)

NOTE: Pivot around rear axle

LATER DEVELOPMENT
 - Store the length of the car/vehicle in the car object; use it to calcualte ETD for each box


